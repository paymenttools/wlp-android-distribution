# Module Whitelabel Pay SDK

## What's new

This is the WhitelabelPay SDK version 1.2.2.

This release adds several improvements to the Whitelabel Pay SDK:
- Fixed an issue with missing proguard rules;
- Improvements for Online Onboarding Flow:
   - added possibility to retrieve digital SEPA Mandate text from `OnboardingFlowDetails.mandateInfo`.

## SDK Installation

### 1. Repository access

On first use you need "read" access to the GitHub repository
that hosts [SDK distribution packages](https://github.com/paymenttools/wlp-android-distribution).

### 2. Get your GitHub token.

To generate a GitHub token, navigate to your GitHub profile → Settings → Developer settings →
Personal access token → Generate new token (classic).
Select the `read:packages` scope.
Click Generate token.<br/>
More details can be
found [here](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic).

### 3. Create/update the github.properties file.

Create the github.properties file in your project at root level. Add the following two properties:

```properties
gpr.usr=YOUR_GITHUB_ACCOUNT
gpr.key=YOUR_GITHUB_TOKEN
```

Make sure to add the file to .gitignore.

### 4. Configure access to the distribution repository.

#### 4.1. Using the Kotlin DSL structure

Open your project's `settings.gradle.kts` file add the following lines in the dependencyResolutionManagement block:

```kotlin
val githubProperties = Properties().apply {
    rootDir.resolve("github.properties").inputStream().use { load(it) }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()

        maven {
            url = uri("https://maven.pkg.github.com/paymenttools/wlp-android-distribution")
            credentials {
                username = githubProperties.getProperty("gpr.usr")
                password = githubProperties.getProperty("gpr.key")
            }
        }
    }
}
```

Add the dependency for the library in the app-level `build.gradle.kts` file of your project:

```kotlin
implementation("com.paymenttools:paymenttoolssdk:x.y.x")
```

#### 4.2. Using Groovy DSL

Open your project's `settings.gradle` file add the following lines in the dependencyResolutionManagement block:

```groovy
dependencyResolutionManagement {
    ...
    repositories {
        ...
        maven {
            url = "https://maven.pkg.github.com/paymenttools/wlp-android-distribution"
            credentials {
                username githubProperties.getProperty("gpr.usr")
                password githubProperties.getProperty("gpr.key")
            }
        }
    }
}
```

Add the dependency for the library in the app-level `build.gradle` file of your project:

```groovy
implementation "com.paymenttools:paymenttoolssdk:x.y.x"
```

## SDK Usage

### 1. Initialization

To make use of the SDK, an instance of WhitelabelPayImplementation needs to be created.

```kotlin
    val wlpSdk = WhitelabelPayImplementation(
    context = context,
    configs = WhitelabelPayConfigurations(...)
)
```

#### WhitelabelPayConfigurations

There are several key points in creating the configuration object to consider:

```kotlin
    val configs = WhitelabelPayConfigurations(
    bundleId = BuildConfig.APPLICATION_ID,
    tenantId = TENANT_ID,
    referenceId = REFERENCE_ID,
    environment = WhitelabelPayEnvironment.INTEGRATION,
    shouldLog = true
)
```

- `TENANT_ID` tenant identifier provided by Payment Tools. Should be set to `rew`.
- `REFERENCE_ID` **Unique** notification identifier for the device.
- `shouldLog` is a boolean value that enables or disables logging.
  The logs are printed in the logcat with the tag `WLP-SDK`.
  The logs are also recorded in a file that can be exported using the `exportLogs` function.

### 2. SubjectId

The `subjectId` is a unique identifier for the enrolled device in the WhitelabelPay system.
It is associated with the `referenceId` value provided by the app implementing the SDK.
The `subjectId` is generated by the WhitelabelPay system after a successful enrolment and can be
retrieved using the following property of the SDK:

```kotlin
    val subjectId = sdk.subjectId
```

If the device is not enrolled, the `subjectId` will be `null`.

### 3. SDK State

The WhitelabelPay SDK offers two ways to check the status of the SDK instance within the
WhitelabelPay system:

```kotlin
    val state = sdk.deviceState()
```

or observe the state changes by observing the `state` StateFlow property:

```kotlin
    sdk.state.collect { state ->
    when (state) {
        State.INACTIVE -> {}
        State.ONBOARDING -> {}
        State.ACTIVE -> {}
    }
}
```

### 4. Online Onboarding

The Online Onboarding flow consists of the following steps:

1. Trigger the Online Onboarding flow initiation  by calling the `startOnlineOnboarding()` function.
   It will register the intent of onboarding with our backend and will prepare everything internally
   to handle the online onboarding.
    ```kotlin
        viewModelScope.launch {
            try {
                paymentRepository.startAlternativeOnboarding()
            } catch (e: Exception) {
                // handle possible errors
            }
        }
    ```
2. Provide the user info details via the `requestOnlineOnboardingURL` function and obtain the
   redirect URL to our 3rd party provider for importing the user bank account.
   The provided user information is validated and, in case of validation failure, a
   `WnitelabelPayError.InvalidUserInfoField` error containing the field type, is thrown.

   Along with the user info, this function also requires string representations 3 URIs:
   - Success redirect
   - Failure redirect
   - Abort redirect

   These URIs are called by the 3rd party provider in case of a successful check flow completion,
   a completion with error or a flow that was aborted before reaching a completion state,
   respectively.
   The redirect URIs must follow this structure:
   - Scheme: Custom, defined by the integrator (e.g., `myapp`, `wlp`)
   - Path: Custom, defined by the integrator (e.g., `success`, `failure`, `aborted`)

   Example of valid URIs:
    ```kotlin
   const val WLP_SUCCESS_REDIRECT = "wlp://success"
   const val WLP_FAILURE_REDIRECT = "wlp://failure"
   const val WLP_ABORT_REDIRECT = "wlp://aborted"
   ```
3. Open the provided URL in a web view and listen for the success, failure and abort redirects.
    ```kotlin
    AndroidView(
        modifier = Modifier.fillMaxSize(),
        factory = { context ->
        WebView(context).apply {
            webViewClient = object : WebViewClient() {
                override fun shouldOverrideUrlLoading(
                    view: WebView?,
                    request: WebResourceRequest?
                ): Boolean {
                    val loadingUrl = request?.url.toString()
                    if (loadingUrl == Constants.WLP_SUCCESS_REDIRECT) {
                        view?.stopLoading()
                        navigateToSuccess()
                        return true
                    }
    
                    if (loadingUrl == Constants.WLP_FAILURE_REDIRECT) {
                        view?.stopLoading()
                        navigateToFailure()
                        return true
                    }
    
                    if (loadingUrl == Constants.WLP_ABORT_REDIRECT) {
                        view?.stopLoading()
                        navigateToAborted()
                        return true
                    }
    
                    return false
                }
            }
   
            settings.javaScriptEnabled = true
            loadUrl(url)
        }
    })
   ```
4. When either redirect is triggered, make sure to call the `fetchOnlineOnboardingDetails` function,
   that will return a flow of `OnboardingFlowDetails`.
   Collect the flow, monitor the value and retrieve the onboarding status and selected bank account
   details or the error in case of
   verification failures.
    ```kotlin
    viewModelScope.launch {
        wlpRepository.fetchOnlineOnboardingDetails().collectLatest { result ->
            result.fold(
                onSuccess = { onboardingFlowInfo ->
                    when (onboardingFlowInfo.status) {
                        OnboardingState.COMPLETED -> {
                            // retrieve and update UI with account holder info:
                            // iban = onboardingFlowInfo.iban,
                            // accountHolder = onboardingFlowInfo.accountHolder
                        }
                        else -> {
                            // Continue watching, optionally update loading state
                        }
                    }
                },
                onFailure = { error ->
                    if (error is WhitelabelPayError.OnlineOnboardingError) {
                        val status = error.status
                        val message = error.errorCause
                        when (status) {
                            OnboardingState.COMPLETED_WITH_ERROR,
                            OnboardingState.ABORTED,
                            OnboardingState.ONBOARD_INIT_FAILED -> {
                                // handle the onboarding flow error
                            }
                            else ->  {
                                // display the error message
                            }
                        }
                    } else {
                        // display the error message
                    }
                }
            )
        }
    }
    ```
5. Using the bank account details received in the previous step, create the
   Sepa Mandate Confirmation UI, which will require the user consent.
   When the user taps the user consent button, make sure to call the `submitSepaMandateConsent`
   function, this will finish the onboarding process and if successful it will switch the SDK into
   an active state.
    ```kotlin
    viewModelScope.launch {
        try {
            wlpRepository.confirmSepaMandate() 
        } catch (e: Error) {
            // handle possible errors
        }
    }
    ```

### 5. Tokens

#### Enrolment token

The enrolment token is used to register a card (once or multiple times) within the WhitelabelPay
system. The sdk provides a function to get the enrolment token:

```kotlin
try {
   val enrolmentToken = sdk.getEnrolmentToken()
} catch (e: WhitelabelPayError.MissingReferenceId) {
   Timber.e("get onboarding token failed: ", e)
}
```

The enrolment token:

- always starts with ***01***;
- it is unique for the device;
- it is not reset for new sdk instances;
- it can be used multiple times when enrolling new or existing cards (bank accounts).

To use the token with the OneScan format, the SDK offers a utility function to get
the string representation of the token:

```kotlin
    val tokenString = enrolmentToken.stringRepresentation()
```

#### Payment token

The payment token is used to make payments within the WhitelabelPay system.
The sdk provides a function to get a payment token (if available):

```kotlin
try {
   val paymentToken = sdk.getPaymentToken()
} catch (e: Exception) {
   Timber.e("get payment token failed: ", e)
}
```

A payment token:

- always start with ***02***;
- it is consumable, meaning that once used to perform a payment; it is no longer valid;
- it has an expiration period of 10 minutes since its generation;
- has an offline limit: once enough tokens are read while offline, no more tokens will be
  available.

Fetching a payment token when there is internet connectivity:

1. It will trigger an API call that returns the data associated with the active card
2. A token will be generated and returned

Fetching a payment token when there is **NO** internet connectivity:

1. A limit is imposed on the number of available tokens while offline
2. A token will be generated and returned while the limit is not reached
3. If the limit is reached, an error will be thrown
4. If the internet connection restores before reaching the limit, the limit resets to its initial value

To use the token with the OneScan format, the SDK offers a utility function to get the
string representation of the token:

```kotlin
    val tokenString = paymentToken.stringRepresentation()
```

#### Observe `token` StateFlow

The SDK offers a StateFlow property to observe the token changes:

```kotlin
sdk.token.collect { token ->
   when (token) {
      is Token.EnrolmentToken -> {
         // handle enrolment token
      }
      is Token.PaymentToken -> {
         // handle payment token
      }
      is Token.Empty -> {
         //handle default value
      }
   }
}
```

### 6. Data synchronization

The SDK offers a function to synchronize all SDK data available on the device (sdk state and card data):

```kotlin
viewModelScope.launch {
   try {
      val state = sdk.sync()
   } catch (e: Exception) {
      Timber.e("sync failed: ", e)
   }
}
```

There's also an overloaded version of the function that accepts a boolean parameter to emit or not
a new token through the `token` StateFlow property:

```kotlin
viewModelScope.launch {
   try {
      val state = sdk.sync(updateToken = true)
   } catch (e: Exception) {
      Timber.e("sync failed: ", e)
   }
}
```

### 7. Monitoring SDK state and token changes

The SDK offers two functions to start and stop monitoring the SDK state and token changes.

#### `startMonitoringUpdates` function

The `startMonitoringUpdates` function starts monitoring the SDK state and token changes.
The function triggers two parallel processes: one to update the token every 30 seconds and one to
update the SDK state every 5 seconds when enrolling a new card and every 10 seconds when making
a payment.
The function offers a callback to handle possible errors when *getting tokens*.

An implementation example would look like this:

```kotlin
fun startObservingChanges() {
   sdk.startMonitoringUpdates(
      onError = { error: WhitelabelPayError ->
         // handle error in your UI
         setErrorMessage(error.message())

         // delete the previous token from the UI
         if (error is WhitelabelPayError.TokenSignatureFailure ||
            error is WhitelabelPayError.GetPaymentMeansError ||
            error is WhitelabelPayError.GetPaymentTokenError ||
            error is WhitelabelPayError.NetworkConnectivityFail ||
            error is WhitelabelPayError.RequestDataSignatureFailure
         ) {
            setToken(null)
            updateCodeImage(null)
         }

         if (error is WhitelabelPayError.InvalidEnrolmentInstance) {
            // todo: Inform the user the SDK instance is invalid and needs to be re-enrolled
         }
      }
   )
}
```

#### `stopMonitoringUpdates` function

The `stopMonitoringUpdates` function stops the monitoring of the SDK state and token changes by
stopping the two parallel processes started by the `startMonitoringUpdates` function.
The function should be called when the screen where the token is shown is destroyed.

An implementation example would look like this:

```kotlin
fun stopObservingChanges() {
   sdk.stopMonitoringUpdates()
}
```

or in a viewmodel:

```kotlin
override fun onCleared() {
   super.onCleared()
   stopObservingChanges()
}
```

### 8. Registered cards operations (payment means)

The SDK offers the functionality to retrieve and manage the already registered cards,
called **payment means** within WhitelabelPay.

#### — Retrieve payment means

```kotlin
try {
   val paymentMeansList = sdk.getPaymentMeansList()
} catch (e: Exception) {
   Timber.e("get payment means list failed: ", e)
}
```

#### — Deactivate an active payment mean

```kotlin
viewModelScope.launch {
   try {
      sdk.deactivatePaymentMeans(
         paymentMeanId = paymentMean.Id,
         onDeactivationSuccess = { }
      )
   } catch (e: Exception) {
      Timber.e("deactivation of payment mean failed: ", e)
   }
}
```

#### — Reactivate an inactive payment mean

```kotlin
viewModelScope.launch {
   try {
      sdk.reactivatePaymentMean(
         paymentMeanId = paymentMean.Id,
         onReactivationSuccess = { }
      )
   } catch (e: Exception) {
      Timber.e("reactivation of payment mean failed: ", e)
   }
}
```

#### — Delete a payment mean

```kotlin
viewModelScope.launch {
   try {
      sdk.deletePaymentMean(
         paymentMeanId = paymentMean.Id,
         onDeletionSuccess = { }
      )
   } catch (e: Exception) {
      Timber.e("deleting payment mean failed: ", e)
   }
}
```

### 9. Sign Off

The *signOff* functionality purges ***ALL*** SDK data from the device, as well as deactivates all
payment means on the backend and changes the mandate status.
The state of the SDK is set to ONBOARDING.

```kotlin
viewModelScope.launch {
   sdk.signOff(
      onSignOffSuccess = { }
   )
}
```

### 10. Reset

The *reset* functionality purges ***ALL*** SDK data from the device, resets the SDK state to INACTIVE.

```kotlin
    viewModelScope.launch {
   wlpSdk.reset()
}
```

### 11. Logging

The SDK offers the functionality to log the main actions that are performed by the SDK.
The SDK has remote logging, enabled by default, and also local logging to logcat and log file.
Enabling the local logging can be done by setting the `shouldLog` parameter to `true` when
initializing the WhitelabelPayConfigurations object.
The logs are printed in the logcat with the tag `WLP-SDK`.

The SDK offers the possibility to export the logs to a file by using the `exportLogs` function.
Here is an example of how to export the logs to the external Downloads directory:

```kotlin
/**
 * Copies the log file to the external Downloads directory.
 * Returns the copied file or null if anything fails.
 */
private fun exportLogFileToDownloads(): File? {
   val logFile = sdk.exportLogs()
   if (logFile == null || !logFile.exists()) return null

   val downloadsDir =
      Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
   if (!downloadsDir.exists()) downloadsDir.mkdirs()

   val exportedFile = File(downloadsDir, "wlp_sdk_logs_${LocalDate.now()}.txt")
   return try {
      logFile.copyTo(exportedFile, overwrite = true)
      exportedFile
   } catch (e: IOException) {
      Timber.tag("SettingsViewModel").e(e, "Failed to export logs")
      null
   }
}
```

### 12. Passing push notifications to WhitelabelPay SDK

The WhitelabelPay SDK offers the functionality to handle push notifications and to react to four
different events:
- enrolment successful;
- enrolment failed;
- payment successful;
- payment failed.

The reaction to these events would be a sync action.
In all cases, except for **enrolment failed**,
a new payment token will be generated and emitted to the observers of the `token` StateFlow property.
Also in the case of **enrolment successful**, the SDK state will be set to `ACTIVE`.

The SDK offers the `handleNotification` function to handle the push notifications.
It accepts a string parameter that represents the type of the notification.
The notification type should be retrieved from the push notification payload:

```kotlin
val eventType = message.data["type"]
try {
   sdk.handleNotification(eventType = eventType)
} catch (e: WhitelabelPayError.WrongNotificationType) {
   Timber.e(e)
}
```

### 13. Exclude WhitelabelPay data from automatic backup

If the Application using WhitelabelPay has automatic backup enabled, make sure the data
generated by the SDK is not persisted in the end-user's Google account.

Here are the steps for achieving this:

#### Changes in the `AndroidManifest.xml` file:

Set the `android:allowBackup` attribute to `"true"` for the `<application>` element. This ensures
that the app's data will be backed up by default.

In the app's `AndroidManifest.xml`, explicitly exclude the shared preferences file from being
backed up by adding the `android:fullBackupContent` attribute to the `<application>` element and
specifying an XML resource that excludes the shared preferences file.

```xml
<application
        android:allowBackup="true"
        android:fullBackupContent="@xml/full_backup_exclude">
   <!-- ... -->
</application>
```

#### Create an XML resource:

Create an XML resource file (for example, `res/xml/full_backup_exclude.xml`) that specifies which files or
directories should be excluded from backups. In this XML file, you can specify that
the shared preferences file shouldn't be backed up. Here is an example of such an XML file:

```xml
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
   <exclude domain="sharedpref" path="wlp-sdk-prefs-bundle-id.xml"/>
</full-backup-content>
```

where `bundle-id` is the value specified at the step: 1. Setup for `bundleId` parameter.
